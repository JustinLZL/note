面向对象编程:Object-Oriented Programing
	

对象是指现实中的物体或实体


	面向对象是指把一切看成对象(实例),用各种对象之间的关系来描述事务



对象的特征:

    对象有很多属性(名词)

        姓名,性别,年龄,...

    对象有很多行为(动作,动词)

        学习,吃饭,睡觉,工作,...



类:拥有相同属性和行为的对象分为一组,即为一个类



类是用来描述对象的工具,用类可以创建此类的对象

语法:

    class 类名(继承列表):

        '''类的文档字符串'''

        实例方法定义

        类变量定义

        类方法定义(@classmethod)

        静态方法定义(@staticmethod)


作用:

    创建一个类

    用于描述对象的行为和属性

    用于创建此类的一个或多个同类对象



说明:

    继承列表可以省略,省略继承列表表示类继承自object

    类名必须为标识符

    类名实质上是变量,它绑定一个类



类的文档字符串:

    类内没有赋值给任何变量的字符串为类的文档字符串

    类的文档字符串由类的__doc__属性绑定

构造函数:

    构造函数调用表达式:

        类名([创建传参列表])

    作用:

        创建这个类的实例对象,并返回实例对象的引用关系



实例说明:

    1.实例有自己的作用域和名字空间,可以为该实例添加实例变量(也叫属性)

    2.实例可以调用类方法和实例方法

    3.实例可以访问类变量和实例变量



实例方法(method):

    语法:

        class 类名(继承列表):

            def 实例方法(self, 形参1, 形参2, ...):

                '''方法的文档字符串'''

                语句块

    作用:

        用于描述一个对象的行为,让此类的全部对象都拥有相同的行为

    说明:

        实例方法的实质是函数,是定义在类里面的函数

        实例方法至少有一个形参,第一个形参表示调用这个方法的实例,一般命名为'self'




实例方法的调用语法:

    实例.实例方法名(调用传参)

    或

    类名.实例方法名(实例,调用传参)



实例属性 attribute(也叫实例变量)

    每个实例都可以用自己的变量,称为实例变量(也叫属性)


    使用语法:

        实例.属性名

    属性的赋值规则:

        1.首次为属性赋值则为创建此属性

        2.再次为属性赋值则改变属性的绑定关系

    作用:

        记录每个对象自身的数据



删除属性

    del语句

    del 对象.属性名



del 语句总结

    1.删除变量 del a

    2.删除列表中的元素 del L[x]

    3.删除字典中的键 del d['name']

    4.删除对象的属性 del dog1.color



初始化方法:

    作用:

        对新创建的对象添加属性等初始化操作

    语法格式:

        class 类名(继承列表):

            def __init__(self[,形参列表])

                语句块


    说明:

        1.初始化方法名必须为__init__不可改变

        2.初始化方法会在构造函数创建实例后自动调用,且将实例自身通过第一个参数self传入__init__方法

        3.构造函数的实参将通过__init__方法的参数列表传入到__init__方法中

        4.初始化方法内如果需要return语句返回,则只能返回None

析构方法

    语法:

        class 类名(继承列表):

            def __del__(self):

                语句块


    作用:

        通常用来释放此对象占用的资源

    说明:

        1.析构方法会在对象被销毁时自动调用

        2.Python语句建议不要在对象销毁时做任何事情,因为对象销毁的时间难以确定



预置的实例属性:

__dict__属性

    绑定一个存储此实例自身变量的字典

__class__属性

    绑定创建此实例的类(类实例)

    作用:

        可以借助于此属性来访问创建此实例的类



类变量

    类变量是类的属性,此属性属于类,不属于类的实例

作用:

    通常用来存储该类对象共有的数据

说明:

    类变量可以通过类直接访问

    类变量可以通过类的实例直接访问

    类变量可以通过此类的对象的__class__属性间接访问


语法:

    class 类名(继承列表):

        类变量名 = 表达式

        ...



类的__slots__属性

    
    __slots__ = [形参列表]

    作用:

        限定一个类创建的实例只能有固定的属性(实例变量),不允许对象添加列表以外的属性

        防止用户因错写属性的名称而发生程序错误

    说明:

        含有__slots__属性的类所创建的实例没有__dict__的属性,即此实例不用字典来存储对象的属性



类方法:

    用于描述类的行为的方法,此方法属于类,不属于该类创造的实例

    说明:

        1.类方法需要使用@classmethod 装饰器定义

        2.类方法至少有一个形参,第一个形参用于绑定类(即cls==类名),约定写为'cls'

        3.类实例和对象实例都可以调用类方法

        4.类方法不能访问此类创建的对象的属性



静态方法@staticmethod

    定义在类的函数,此函数的作用域是类的内部

    说明:

        静态方法需要使用staticmethod装饰器定义

        静态方法与普通函数定义相同,不需要传入self实例参数和cls类参数

        静态方法只能凭借该类或类的实例调用

        静态方法不能访问类变量和实例变量(属性)



继承 inheritance 和 派生 derived

    继承是从已有的类中派生出新的类,新类具有原类的行为,并能扩展新的行为

    派生类就是从一个已有的类衍生出的新类,在新类中可以添加新的属性和行为


    作用:

        1.用继承派生机制,可以将一些共有功能加在基类中,实现代码共享

        2.在不改变超类的代码的基础上改变原有的功能

    名词:

        基类(base class)/超类(super class)/父类(father class)

        派生类(derived class)/子类



单继承:

    语法:

        class 类名(基类名):

            语句块

    说明:

        单继承是指派生类由一个基类衍生出来



继承说明:

    任何类都直接或间接地继承自Object类

    Object类是一切类的超类



类的__base__属性

    __base__属性用来记录此类的基类



覆盖 override

    在有继承关系的类中,子类中实现了与基类同名的方法,在子类实例调用该方法的时候,实际调用的是子类中覆盖版本的方法的现象叫覆盖



super 函数:

    super(type, Obj)  返回绑定超类的实例(要求Obj必须为type类型的实例)

    super()           返回绑定超类的实例,等同于super(__class__,实例方法的第一个参数),必须用在方法内调用


作用:

    返回绑定超类的实例,用超类的实例来调用其父类的覆盖方法



显式调用基类的构造方法:

    当子类中实现了__init__方法,基类的构造方法并不会调用,此时需要显式调用基类的构造方法


用于类的函数:

    
    isinstance(obj, class_or_tuple) 返回这个对象是否是某个类的对象,或者某些类中的对象,如果是则返回True,否则False

    
    type(obj)   返回对象的类


        issubclass(cls, class_or_tuple) 判断一个类是否继承自其它的类,如果此类cls是class或tuple中的一个派生子类则返回True,否则False



封装 (enclosure)

    封装是指隐藏类的实现细节,令使用者不用关心这些细节

    封装的目的是让使用者通过尽可能少的方法(或属性)

操作对象

私有属性和方法:

    Python类中以双下划线开头,不以双下划线结尾的标识符为私有成员,私有成员只能用此类的方法进行访问



多态 polymorphic

    字面意思:多种状态

    多态是指在有继承/派生关系的类中,调用基类对象的方法,实际能调用子类的覆盖方法的现象


    状态:静态(编译时状态)
    动态(运行时状态)


    说明:

        多态调用的方法与对象有关,不与类型相关

        Python全部对象都只有动态,没有'C++语言'里的静态



面向对象的编程语言的特征

    封装
    继承/派生
    多态



多继承 multiple inheritance

    多继承是指一个子类继承自两个或两个以上的基类


    语法:

        class 类名(基类名1, 基类名2,...)

    说明:

        1.一个子类同时继承自多个父类,父类中的方法可以同时被继承下来
        
2.如果两个父类中有同名的方法,但在子类中没有覆盖此方法时,则调用结果难以确定


    缺陷:

        标识符(名字空间)冲突的问题

            要谨慎使用多继承



多继承的mro(method order)属性:

    类的__mro__属性:

        用来记录属性(或方法)的查找顺序



函数重写 overwrite

    在自定义的类内添加相应的方法,让自定义的类生成的对象(实例)像内建对象一样进行函数操作



对象转字符串函数:

    
repr(x) 返回一个能代表此对象的表达式字符串,通常: eval(repr(obj)) = obj


    str(obj) 通过给定对象,返回一个字符串(这个字符串通常是给人阅读的)



对象转字符串函数的重写方法

    repr() 函数的重写方法

        def __repr__(self):

            ...

            return 字符串


    str() 函数的重写方法

        def __str__(self):

            ...

            return 字符串



str(obj) 函数调用的方法说明:

    1.str(Obj) 函数先查找Obj.__str__()方法,调用此方法并返回结果

    2.如果Obj.__str__()方法不存在,则调用Obj.__repr__()方法并返回结果

    3.如果Obj.__repr__()方法不存在,则调用Object类的__repr__实例方法显示

    
<__main__.类名 object at xxx>格式

内建函数重写

    __abs__         abs(obj)函数调用

    __len__         len(obj)函数调用

    __reversed__    reversed(obj)函数调用

    __round__       round(obj)函数调用

数值转换函数重写

    __complex__     complex(obj) 函数调用

    __int__         int(obj) 函数调用

    __float__       float(obj) 函数调用

    __bool__        bool(obj) 函数调用

布尔测试函数重写


    def __bool__(self):

        ...

    
作用:

        用于bool(obj) 函数取值

        用于if 语句真值表达式中

        用于while 语句的值表达式中
    
说明:

        1.当自定义类内有__bool__(self)方法时,以此方法的返回值作为bool(obj) 的返回值

        2.当不存在__bool__(self) 方法时,bool(x) 返回__len__(self) 方法的返回值是否为零来测试布尔值

        3.当不存在__len__(self) 方法时,则直接返回True



迭代器

    可以通过next 函数取值的对象就是迭代器

迭代器协议

    指对象能够使用next 函数获取下一个数据,在没有下一项数据时触发一个StoptIteration异常来终止迭代的约定



迭代器的实现方法:

    __next__(self)

可迭代对象

    指能用iter(obj) 函数返回迭代器对象

    可迭代对象内部要定义__iter__(self) 方法来返回迭代器对象



可迭代对象的语法形式:

    class myiterable:

        def __iter__(self):
    
        语句块

            return 迭代器

异常



with 语句

    语法:

        with 表达式1 [as 变量1], 表达式2 [as 变量2], ...:

            语句块

    作用:

        使用于对资源进行访问的场合,确保使用过程中不管是否发生异常,都会执行必须的'清理'操作,并释放内存

        如:文件使用后自动关闭,线程中锁的自动获取和释放等

    说明:

        执行表达式 用as 子句中的变量绑定生成的对象

        with 语句并不必变异常的状态



环境管理器(也叫上下文管理器)

    1.类内有__enter__方法和__exit__

        实例方法的类被称为环境管理器

    2.能够用with 语句进行管理的对象必须是环境管理器

    3.__enter__将在进入with 语句时被调用,并返回由as 变量绑定的对象

    4.__exit__将在离开with 语句时被调用,且可以用参数来判断在离开with 语句时是否有异常发生并做出相应的处理



运算符重载:

    让自定义的类生成的对象(实例)能够实例运算符进行操作

    作用:

        让自定义类的实例像内建对象一样运行运算符操作

        让程序简洁易读

        对自定义的对象将运算符赋予新的运算规则

    说明:

        运算符重载方法的参数已经有固定的含义,不建议改变原有的意义

算术运算重载

    方法名

    __add__(self, rhs)        self + rhs      加法

    __sub__(self, rhs)        self - rhs      减法

    __mul__(self, rhs)        self * rhs      乘法

    __truediv__(self, rhs)    self / rhs      除法

    __floordiv__(self, rhs)   self // rhs     地板除

    __mod__(self, rhs)        self % rhs      求余(取模)

    __pow__(self, rhs)        self ** rhs     幂运算



    *rhs(right hand side) 右手边



二元运算符的重载方法格式

    def __xxx__(self, other):

        运算规则的语句

反向算术运算符的重载

        方法名

    __radd__(self, lhs)       lhs + self      加法

    __rsub__(self, lhs)       lhs - self      减法

    __rmul__(self, lhs)       lhs * self      乘法

    __rtruediv__(self, lhs)   lhs / self      除法

    __rfloordiv__(self, lhs)  lhs // self     地板除

    __rmod__(self, lhs)       lhs % self      求余(取模)

    __rpow__(self, lhs)       lhs ** self     幂运算



复合赋值算术运算符重载

    以复合赋值算术运算符 x += y 为例,此运算符会优先调用x.__iadd__(y)方法,如果没有__iadd__方法时将复合赋值运算符

    拆分为x = x + y, 然后调用x = x.__add__(y)方法,如果不存在__add__方法则触发typeerror异常


        方法名

    __iadd__(self, rhs)          self += rhs      加法

    __isub__(self, rhs)          self -= rhs      减法

    __imul__(self, rhs)          self *= rhs      乘法

    __itruediv__(self, rhs)      self /= rhs      除法

    __ifloordiv__(self, rhs)     self //= rhs     地板除

    __imod__(self, rhs)          self %= rhs      求余(取模)

    __ipow__(self, rhs)          self **= rhs     幂运算



比较运算符的重载

    方法名

    __lt__(self, rhs)      self < rhs      小于

    __le__(self, rhs)      self <= rhs     小于等于

    __gt__(self, rhs)      self > rhs      大于

    __ge__(self, rhs)      self >= rhs     大于等于

    __eq__(self, rhs)      self == rhs     等于

    __ne__(self, rhs)      self != rhs     不等于



位运算符的重载

    __invert__(self, rhs)      ~self            取反(一元运算符)

    __and__(self, rhs)          self & rhs      位与

    __or__(self, rhs)           self | rhs      位或

    __xor__(self, rhs)          self ^ rhs      位异或

    __lshift__(self, rhs)      self << rhs      左移

    __rshift__(self, rhs)      self >> rhs      右移



反向位运算符的重载

    __rand__(self, lhs)          lhs & self      位与

    __ror__(self, lhs)           lhs | self      位或

    __rxor__(self, lhs)          lhs ^ self      位异或

    __rlshift__(self, lhs)      lhs << self      左移

    __rrshift__(self, lhs)      lhs >> self      右移



复合赋值位运算符的重载

    __iand__(self, rhs)          self &= rhs      位与

    __ior__(self, rhs)           self |= rhs      位或

    __ixor__(self, rhs)          self ^= rhs      位异或

    __ilshift__(self, rhs)      self <<= rhs      左移

    __irshift__(self, rhs)      self >>= rhs      右移



一元运算符的重载

    __neg__(self)         - self       负号

    __pos__(self)         + self       正号

    __invert__(self)      ~ self       取反


    语法格式:

        def __xxx__(self):

            ...
in / not in
 
    __contains__(self, e):
       e in self

   成员运算

索引和切片运算符的重载

重载方法

__getitem__(self, i)        x = self[i]     索引/切片取值

__setitem__(self, i, val)   self.[i] = val  索引/切片赋值

__delitem__(self, i)        del self[i]     del语句索引/切片



作用:

    让自定义的类型的对象能够支持索引和切片操作



slice 构造函数

    作用:

        用于创建一个slice切片对象,此对象存储一个切片起始值,终止值,步长值信息

    格式:

        slice(start=None, stop=None, step=None) 创建一个slice切片对象