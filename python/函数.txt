函数　function
    
	函数是可以重复执行的语句块，可以重复调用
    
	用于封装语句，提高代码的重用性
    
	用于定义(创建)用户级别的函数
    
		def 函数名(形参列表)：
        
		    语句块

    
	1.函数名就是语句块的名称
    
	2.函数名的命名规则与变量相同(函数名必须是标示符)
    
	3.函数名是一个变量
    
	4.函数有自己的名字空间，在函数外部不可以访问函数内部的变量，在函数内部可以
访问函数外部的变量，要让函数处理外部数据需要用参数给函数传入一些数据
    
	5.参数列表可以为空
    
	6.语句不能为空，如果需要空则用pass语句填充



函数调用
    
	函数名(实际调用传递参数)
    
	
	函数调用是一个表达式
    
	如果没有return语句，函数执行完毕后返回None对象
    
	如果函数需要返回其他的对象需要用到return语句



函数的定义：
    
	def 函数名(形参列表)
        
	    语句块

    
	创建一个函数，把函数内的语句块打包成为一个函数，用函数名绑定



return语句
    
	return [表达式]
    
	[]可省略,省略后相当于return None
    
	用于函数中,结束当前函数的执行,返回到调用该函数的地方,同时返回表达式的引用关系
    
	如果函数内没有return 语句,则函数执行完最后一条语句后返回None



函数的参数传递
    
	传递方式:
        
		位置传参
            
		序列传参

	        关键字传参(*L)

                字典关键字传参(**d)



	位置传参:
实际传递参数(以下简称实参)与形式参数(形参)的对应关系按位置来依次对应


	
	关键字传参:
关键字传参是指传参时,按着形参的名称给形参赋值,实参和形参的名称相对应


	字典关键字传参:
是指实参为字典,将字典用'**'拆解后进行关键字传参的传参方式
    

		def myfun(a,b,c):
        
		    print('a=',a)
    
		    print('b=',b)
    
		    print('c=',c)
    
	
		d={'a':111,'b':222,'c':333}
    
		myfun(**d)

    
		
	字典的键名和形参名必须一致
    
	字典的键名必须为字符串(而且必须为标识符的规则)
    
	字典的键名要在形参中存在



函数的综合传参:
    
	函数的传参方式在能确定形参能唯一匹配到对应实参的情况下可以任意组合
    
	
	要求:
位置传参在前,关键字传参在后
        

		def myfun(a,b,c):
         
		    print('a=',a)
        
		    print('b=',b)
        
		    print('c=',c)

        
		
		myfun(1,c=3,b=2) #正确
        
		myfun(a=3,b=2,1) #错误
        
		myfun(1,*[2,3])  #正确
        
		myfun(*'AB',3)   #正确
        
		myfun(*[1],c=3,b=2)#正确
        
		myfun(1,**{'c':3,b':2})#正确



函数的缺省参数
    
	def 函数名(形参数1=默认实参1, 形参数2=默认实参2, ...):
    

	1.缺省参数必须自右向左依次存在,如果一个参数有缺省值参数,则其右边的所有参数都必须有缺省参数
        
		def fa(a=1,b,c=3) #错误
        
		def fa(a,b=2,c) #错误
    
	2.缺省值参数可有0个或多个,甚至全部都是缺省参数



函数形参的定义方式:
    
	位置形参
    
	星号元组形参
    
	命名关键字形参
    
	双星号字典形参



	位置形参:
    
		def 函数名(形参名1,形参名2, ...):
        
		    语句块


	星号元组形参:
    
		def 函数名(*元组形参名):
        
		    语句块
    
	    收集多余的位置传参


		def fa(*args):
    
		'''args绑定一个元组'''
    
		    print('实参个数是:',len(args))
    
		    print('args=',args)
	
		

fa()

		fa(1,2,3,4)


	命名关键字形参:
    
	    def 函数名(*,命名关键字形参):
        
		语句块
    
	或
    
	    def 函数名(*args,命名关键字形参):
    
	        语句块
    
	    强制所有的传参都必须用关键字传参
	    	

def fa(a,b,*,c,d):
    
		'''c,d必须用关键字传参'''
    
		    print(a,b,c,d)
	
		

fa(1,2,3,4) 	#错误

		fa(1,2,c=3,d=4) #正确


	
		def fa(a,b,*args,c,d):
	    
    '''c,d必须用关键字传参'''
    
		    print(a,b,args,c,d)



		fa(1,2,3,4,d=20,c=10)		#1 2 (3, 4) 10 20

		fa(1,2,3,4,5,**{'d':20,'c':10}) #1 2 (3, 4, 5) 10 20



	双星号字典形参:
    
		def 函数名(**字典形参名):
	    
        语句块
    
	    收集多余的关键字传参


		def fa(**kwargs):
    
		'''kwargs绑定字典'''
    
		    print('多余的关键字传参个数是:', len(kwargs))
    
		    print('kwargs=', kwargs)



		fa(a=10,b=20,c=30)



函数的参数说明:
    
	位置形参,星号元组形参,命名关键字形参,双星号字典形参,缺省参数可以混合使用
	

函数参数自左向右的顺序依次为:
位置形参>>星号元组形参>>命名关键字形参>>双星号字典形参
		

e.g.:
def fn(a, b, *args,  *, c, d, **kwargs):
    
			print(a,b,args,c,d,kwargs)
		     

fn(1,2,3,4,c=100,d=200,e=300,f=400)  #1 2 (3, 4) 100 200 {'e':300, 'f':400}



局部变量(多用):
    
	1.定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    
	2.局部变量只能在函数内部使用
    
	3.局部变量在函数调用时才能被创建,在函数调用结束后会自动销毁


局部变量说明:
    
	1.在函数内首次对变量赋值是创建局部变量,再次变量赋值是修改局部变量的绑定关系
    
	2.在函数内部的赋值语句不会对全局变量造成影响
    
	3.局部变量只能在起被声明的函数内部访问,而全局变量可以在整个模块被访问











全局变量:
    
	1.定义在函数外部,模块内的变量称为全局变量
    
	2.所有的函数都可以直接访问全局变量,但函数内部不能直接通过赋值语句来改变全局变量



函数变量:
    
	函数名是变量,它在创建时绑定一个函数

一个函数可以作为另一个函数实参传递
		
eg:
def f1():
    
		       print('f1被调用')
		   

def f2():
    
		       print('f2被调用')
		   

def fx(fn):
		   
    print('fn绑定的是:',fn)
    

		   fn()    #调用fn绑定的函数
		

>>> fx(f1)
fn绑定的是: <function f1 at 0x7f42d1767f28>
f1被调用
		
>>> fx(f2)
fn绑定的是: <function f2 at 0x7f42cfff62f0>
f2被调用




案例:

		def myinput(fn):
		
    L = []
    
		    while True:
		
        x = int(input('请输入大于0的整数:') or '-1')
		
        if x < 0:
            
			    break
        
			L.append(x)
			
    return fn(L)



		print(myinput(max))

		print(myinput(min))
		
print(myinput(sum))




	函数作为另一个函数的返回值
		

def get_op():
		
    s = input('请输入您要的操作:')
		
    if s == '求最大':
		
        return max
		
    elif s == '求最小':
		
        return min
		
    elif s == '求和':
		
        return sum

		

L = [1, 2, 3, 4]
		
fx = get_op()

		print( fx(L) )




函数嵌套
	定义:指一个函数里面用def语句来创建其他函数的情况
		

def fun_outer():
		
    print('fun_outer被调用...')
    #在此处创建另一个函数函数,并在下面调用
		
    def fun_inner():
		
        print('fun_inner被调用')
		
    fun_inner()
		
    fun_inner()
		    

print('fun_outer调用结束')

		

>>>fun_outer()

		fun_outer被调用...
		
fun_inner被调用
		
fun_inner被调用
		
fun_outer调用结束




python的作用域

    作用域也叫命名空间(namespace),是访问变量时查找变量名的范围空间
	

四个作用域:LEGB

    

作用域                  
	英文解释             		英文简写		局部作用域(函数内)		

	local(function)         	  L		

	外部嵌套函数作用域    
	enclosing function locals         E			

函数定义所在模块          
	globals(module)               	  G			
文件的作用域
	builtins                   	  B			

python内置模块的作用域



变量名的查规则
	
1.在访问变量先查找本地变量,然后是包裹此函数外部的函数内部变量,之后是全局变量,最后是内置(内建)变量
		L>>>>>E>>>>>G>>>>>B
	
2.在默认情况下,变量名赋值会创建或改变本地作用域变量



globals() 函数和locals() 函数
  
		globals()  返回当前全局作用域内变量的字典
  
		locals()   返回当前局部作用域内变量的字典
	


global 语句:
    
	1.告诉解释器,global语句声明的一个或多个变量,这些变量的作用域为模块级的作用域(也称作全局变量)
    
	2.全局声明(global)
    将赋值的变量映射到模块文件内部的作用域

    
		global 变量1,变量2,...



global说明:
	
1.全局变量如果要在函数内部被赋值,则必须经过全局声明(否则会被认为是局部变量)
	
2.全局变量在函数内部不经过声明就可以直接访问

	3.不能先创建局部变量,再用global声明为全局变量
	
4.global变量列表里的变量名不能出现在此作用域形参列表里



nonlocal 语句
    
	告诉解释器,nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量

    

nonlocal的语法
        
	nonlocal 变量名1,变量名2,...
    

nonlocal说明:
        
	1.nonlocal语句只能用于被嵌套的函数内部进行使用
        
	2.访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
        
	3.当两层或以上函数嵌套时,访问nonlocal变量只对最近一层的变量进行操作
        
	4.nonlocal语句的变量列表里的变量名,不能出现在此函数参数列表中



lambda表达式
    
	创建一个匿名函数对象
    
	同def 类似,但不提供函数名

    
		lambda [形参1,形参2,...]:表达式
    

	e.g.:
    myadd = lambda a, b : a + b 
    
		#等同于#def myadd(a,b):
		   
        #return a+b
     
    
	
	1.lambda只是一个表达式，它用来创建一个函数对象
    
	2.当lambda表达式调用时，先执行冒号后的表达式，并返回表达式的结果的引用
    
	3.lambda表达式创建的函数只能包含一条表达式
    

lambda比函数简单而且可以随时创建和销毁，有利于减少程序的耦合度


    def fx(f, x, y):
    
    print(f(x, y))



    fx((lambda a, b : a + b), 100, 200)		#

300
    
fx((lambda a, b : a ** b), 3, 4)		#
81




eval 函数

    把一个字符串当成一个表达式来执行,返回表达式执行后的结果
	
    eval(source, globals=None, locals=None)



exec 函数:

    把一个字符串当作程序来执行
	
    exec(source, globals=None, locals=None)



函数式编程

    用一系列函数解决问题
    

函数是一等公民

    1.函数本身可以赋值给变量,赋值后变量绑定函数

    2.允许将函数本身作为参数传入另一个函数

    3.允许函数返回一个函数

好处:
    
	用每一个函数完成细小的功能,一系列函数在任意组合后可以完成大问题



函数的可重入性:
    
	当一个函数在运行时不会读取和改变除局部作用域以外的变量时,此函数为可重入函数
    
	可重入函数在每次调用时,如果参数一定,则结果必然一定



高阶函数 high order function

    满足下列条件中一个的函数即为高阶函数

        1.函数接收一个或多个函数作为参数传入

        2.函数返回一个函数


    python中内建的高阶函数:

        map函数:
		map(function, *iterables) 
	用函数和对可迭代对象中的每一个元素作为参数,返回新的可迭代对象
	当最短的一个可迭代对象不再提供数据时迭代结束

        func函数接收的参数个数必须和可迭代对象个数相同


		
		def power2(x):
		
    return x **2
 
		#生成一个可迭代对象,此可迭代对象可以生成1-9的自然数的平方		
		
for x in map(power2, range(1, 10)):
		
    print(x)



	filter 函数:

		filter(function, iterable)
    
	筛选可迭代对象iterable中的数据,返回一个新的可迭代对象,新的可迭代对象将对iterable提供的数据进行筛选
    
	函数function将对iterable中的每个元素进行求布尔值,返回True则保留,反之丢弃
	

    def isodd(x):
	
        return x % 2 == 1

	    for x in filter(isodd, range(41, 53)):
	
        print(x)
    


	sorted 函数:
    
		sorted(iterable, key=None, reverse=False)
	将原可迭代对象提供的数据进行排序,生成排序后的列表

    
   
     key 函数是用来提供一个排序参考值的函数,这个函数的返回值将作为排序的依据
	
    reverse=False 升序, 反之降序



递归函数 recursion

    函数直接或间接地调用自身

    递归一定要控制递归的层数,当符合一定条件时要终止递归调用

    几乎所有的递归都能用while循环来代替

    递归可以把问题简单化,让思路更加清晰,代码更简洁

    递归因系统环境影响大,当递归深度太大时,可能会得到不可预知的结果



递归的两个阶段:


    递推阶段:从原问题出发,按递归公式递推从未知到已知,最终达到递归的终止条件

    
回归阶段:按递归终止条件求出结果,逆向逐步代入递归公式,回归到问题求解



递归的实现方法

    先假设函数已经实现



闭包 closure
    闭包是指引用了此函数外部嵌套函数作用域变量的函数



闭包必须满足三个条件

	1.必须有内嵌函数
	
2.内嵌函数必须引用外部函数中的变量
	
3.外部函数返回值必须是内嵌函数


	e.g.:
		
def make_power(y):
		
    def fn(x):
		
        return x ** y

		    return fn




装饰器 decorators

    是一个函数,主要作用是用来包装另一个函数或类

    是在不改变原函数名(或类名)的情况下改变被包装对象的行为



函数装饰器:

    装饰器是一个函数,传入的是一个函数,返回的也是一个函数
	

def 装饰器函数名(参数):
	
    语句块
	
    return 函数对象
	

@装饰器函数名2
	
@装饰器函数名1
	
def 函数名(形参列表):
	
    语句块

函数的文档字符串:
	
    函数内第一次未赋值给任何变量的字符串是此函数的文档字符串
	
def 函数名(形参列表):
	
    '''函数的文档字符串'''
	
    函数语句块

    示例：

        def hello():

            '''此函数用来打招呼．．．

            这是函数的文档字符串'''
            pass


        >>>help(hello)


    1.文档字符串通常用来说明本函数的功能和使用方法

    2.在交互模式下,输入help(函数名)可以查看函数的文档字符串

函数的__doc__的属性

__doc__属性用于记录文档文件

函数的__name__属性

__name__属性用于记录函数的名称



函数的定义语法:

    @装饰器1

    @装饰器2

    ...

    def 函数名(位置形参,*元组形参(或*),命名关键字形参,**字典形参):

        '''文档字符串'''

        语句块




L = [1, 2, 3]

def f(n= 0, lst=[]):

    lst.append(n)

    print(lst)



>>> f(4, L) #
[1, 2, 3, 4]

>>> f(5, L) #
[1, 2, 3, 4, 5]

>>> f(100) #
[100]

>>> f(200)
 #[100, 200]




L = [1, 2, 3]

def f(n=0, lst=None):

    if lst is None:

        lst = []

    lst.append(n)

    print(lst)



>>> f(4, L) #
[1, 2, 3, 4]

>>> f(5, L) #
[1, 2, 3, 4, 5]

>>> f(100) #
[100]

>>> f(200)
 #[200]