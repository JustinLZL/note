网络的作用 : 进行数据的传输

1.OSI 七层模型 : 网络通信标准化流程
	1.组成(最理想):
		应用层 : 提供用户服务,具体内容由特定的程序决定(什么应用提供什么服务)
		表示层 : 数据的压缩优化
		会话层 : 建立应用连接,选择传输层服务
		传输层 : 提供不同的传输服务,流量控制(重点)
		网络层 : 路由(网络路径)选择,网络互连
		链路层 : 提供链路交换,具体消息以帧发送
		物理层 : 物理硬件,接口,网卡,线路
	2.优点
		将功能分开,降低了网络传输中的耦合性,每一部分完成自己的功能.可以在开发和实施过程中各司其职.

高内聚 : 单个模块功能尽量单一
低耦合 : 模块之间尽量减少关联和影响

四层模型
	应用层 : 应用层 表示层 会话层
	传输层 : 传输层
	网络层 : 网络层
	物理链路层 : 链路层 物理层

五层模型(tcp/ip模型)
	应用层 : 应用层 表示层 会话层
	传输层 : 传输层
	网络层 : 网络层
	链路层 : 链路层
	物理层 : 物理层

2.协议(网络协议) : 在网络通信中,各方必须遵守的规定.包括建立什么样的连接,消息结构等
	应用层 : TETP HTTP DNS SMTP
	传输层 : TCP UDP
	网络层 : IP
	物理层 : IEEE
	常用 : HTTP TCP UDP

3.网络基本概念
	1.主机 : "localhost" / '127.0.0.1' 表示本台计算机
	2.网络上 : 
		1.只在本地测试使用 
			"localhost" / '127.0.0.1'
		2.在网络上进行测试(局域网内)
			'0.0.0.0'(本地网卡)  ''  'xxx.xxx.xxx.xxx'(本机ip,明确给定)

查看 IP网络信息
Linux:在终端输入'ifconfig'
Windows:在cmd输入'ipconfig'

获取计算机名称
In [2]: socket.gethostname()
Out[2]: 'tedu'
获取主机IP
In [4]: socket.gethostbyname('localhost')
Out[4]: '127.0.0.1'
In [5]: socket.gethostbyname('tedu')
Out[5]: '127.0.1.1'
In [6]: socket.gethostbyname('')
Out[6]: '0.0.0.0'

4.IP地址 : 在网络上用于区分一台计算机
	IPv4 : 点分十进制	e.g.:192.168.1.72
		   32位二进制表示

	IPv6 : 128位二进制表示

5.网络连接测试命令 : ping  172.60.50.92

6.特殊IP:
	127.0.0.1		本地测试IP
	0.0.0.0			本地网卡通用IP
	192.168.1.0		表示当前网段
	192.168.1.1 	表示网关(局域网内控制路由的ip)
	192.168.1.255	广播地址

7.域名 : 网络服务器IP地址的名称

8.URL(统一资源定位器) : 在网络上定位某个资源位置的字串

9.端口号 : 
	1.网络地址的一部分,在一个系统中,每个网络应用都会有一个唯一的端口号,用来区别其他应用,接受发往这个端口的信息.
	2.数字范围 : 1~65535
		1~255 : 一些众所周知的端口
		256~1023 : 系统应用
		1024~65535 : 自用
		自用推荐使用 >10000
	3.测试一个软件的端口号
		In [16]: socket.getservbyname('http')
		Out[16]: 80

10.传输层服务
	1.面向连接的传输服务
		1.遵循tcp协议
		2.tcp传输的特征:
			1.提供可靠的传输服务
				可靠性表现:数据传输过程中,无失序,无差错,无重复,无丢失
			2.传输过程中有建立和断开连接的过程(/机制)
				三次握手 : 建立数据传输两端的持续连接
					1.客户端向服务器发送连接请求
					2.服务器收到连接请求进行确定,返回报文
					3.客户端收到服务器确定进行连接创建
				四次挥手 : 断开连接的两端,保证数据的传输完整
					1.主动方发送报文,告知被动方要断开连接
					2.被动方返回报文,告知收到请求,准备断开
					3.被动方再次发送报文,告知准备完毕可以断开
					4.主动方发送报文完成断开
	适用情况:文件的上传下载,网络情况良好,需要必须保证可靠性的情况
			e.g.信息聊天,邮件,网页获取
	2.面向无连接的传输服务
		1.遵循udp协议                                        
		2.udp传输的特征
			1.不保证传输的可靠性
			2.无需建立三次握手和四次挥手的连接断开过程
			3.消息的收发比较自由,不受其他约束
	适用情况:网络情况较差,对可靠性要求不高,收发消息的两端不适合建立固定连接
			e.g.网络视频,群聊,发送广播

问题总结:
1.osi模型
2.三次握手和四次挥手
3.tcp和udp的区别

socket套接字编程
	1.目的:通过编程语言提供的函数接口进行组合,更简单的完成基于tcp和udp通信的网络编程
	2.套接字:完成上述目标的编程方法方案
		1.套接字主要的分类
			1.流式套接字(SOCK_STREAM)
				传输层基于tcp的协议进行通信
			2.数据报套接字(SOCK_DGRAM)
				传输层基于udp的协议进行通信
			3.底层套接字(SOCK_RAM)
				访问底层协议的套接字

TCP套接字

from socket import *

1.创建套接字
语法:
	socket.socket(socket_family = AF_INET,
				  socket_type = SOCK_STREAM,
				  proto = 0)
	e.g.:s = socket(AF_INET,SOCK_STREAM)
功能:创建一个套接字
参数:
	socket_family:选择地址族类型 AF_INET 表示IPv4
	socket_type:选择套接字类型 SOCK_STREAM 流式
	 						  SOCK_DGRAM 数据报
	proto:选择子协议,通常为0
返回值:返回一个套接字对象

2.绑定IP端口
	s.bind()
e.g.: s.bind(('192.168.1.2',8888))
功能:绑定IP和端口
参数:二元元组,第一项为IP 第二项为端口号
		e.g.('192.168.1.2',8888)

3.将套接字设置为可监听
	s.listen(n)
功能:将套接字设置为监听套接字,并设置监听队列
参数:设置队列中监听对象的数量 n为大于0的正整数

4.等待客户端的连接
	connfd,addr = s.accept()
功能:阻塞等待客户端连接
返回值:
	connfd  一个新的套接字,用于和指定的客户端通信
	addr	连接的客户端的地址

阻塞函数:程序运行到阻塞位置,如果某种预期条件没有达成则暂停继续运行,直到条件达成后再继续运行

5.消息收发
	data = connfd.recv(buffersize)
功能:接收信息
参数:每次最多接收的信息的大小  bytes
返回值:返回接收到的内容,为字节流,需要decode()

	n = connfd.send(data)
功能:发送信息
参数:要发送的内容  (必须是bytes格式,可以用encode()转码)
返回值:实际发送的字节数

6.关闭套接字
	.close()
功能:关闭套接字,tcp连接断开

*在终端输入 telnet ip port 表示连接tcp服务端

tcp客户端
	1.创建套接字
		s = socket()
		通信两端的套接字类型一定要相同

	2.发起连接
		s.connect()
		e.g.:s.connect(('127.0.0.1',8888))
		功能:发起连接请求
		参数:元组,服务器端的地址('ip',port)

	3.发收消息
		send & recv
		两端收发需要配合
		
	4.关闭套接字
		s.close()

recv()特征:
	1.如果连接端断开,recv会立即结束阻塞返回空字符串
	2.当接收缓冲区为空时会阻塞
	3.如果recv一次接受不完缓冲区内容,下次会继续接收,以确保数据不丢失

send()特征:
	1.如果另一端不存在,还试图通过使用send进行发送则会产生BrokenPipeError异常
	2.当发送缓冲区满时会阻塞

网络收发缓冲区
	1.缓冲区的功能:
		1.协调读写速度
		2.减少与磁盘的交互次数
	2.recv和send 实际上是从缓冲区获取和发送内容

tcp粘包:
	产生原因:tcp传输采用字节流的方式传输,消息之间没有边界,如果发送和接受的速度不匹配,会造成多次发送的内容没有被一次接受,形成意义上的误解即粘包
	产生条件:当使用send快速的连续发送极有可能产生粘包
	影响:
		1.如果每次发送的内容代表一个独立的意思,此时产生的粘包需要处理
		2.如果多次发送的内容本身是一个连续的整体,则不需要处理该粘包(e.g.:文件传输)
	处理方法:
		1.每次发送后加一个结尾标志,接收端通过标志进行判断
		2.发送一个数据结构
		3.每次发送中间有一个短暂的延迟

基于udp的通信
from socket import *

1.服务端
	1.创建数据报套接字
		s = socket(AF_INET,SOCK_DGRAM)
	2.绑定服务端地址
		s.bind()
	3.收发消息
		data,addr = s.recvfrom(buffersize)
			功能:接收udp消息
			参数:每次最多接收消息的大小
			返回值:data	接收的消息
				  addr  消息发送者的地址
		s.sendto(data,addr)
			功能:udp发送消息
			参数:data  要发送的消息(bytes格式)
				addr  目标地址
			返回值:发送的字节
	4.关闭套接字
		s.close()

sys.argv
功能:获取来自命令行的参数,以' '进行分割,输出参数列表(命令行内容均作为字符串传入,所以列表内的参数全是字符串格式)

2.客户端
	1.创建套接字
		s = socke(AF_INET, SOCK_DGRAM)
	2.消息收发
		data addr = s.recvfrom(buffersize)
		s.sendto('something'.encode(),addr)
	3.关闭套接字
		s.close()

tcp流式套接字和udp数据报套接字的区别:
1.流式套接字采用字节流的方式传输数据,而数据报套接字以数据报形式传输
2.tcp会产生粘包现象,udp消息是有边界的所以不会粘包
3.tcp传输是建立在连接的基础上,保证传输的可靠性;而udp一次接受一个数据报,不保证完整性
4.tcp需要依赖listen accept建立连接,udp不用
5.tcp收发消息使用recv send ,udp用recvfrom sendto

sendall()
功能:同send() 作为tcp消息发送
参数:同send()
返回值:发送成功返回none,发送失败返回异常


socket模块和套接字属性

s = socket.socket()

s.type:获取套接字类型
s.family:获取地址族类型

s.fileno()
功能:获取套接字的文件描述符
文件描述符:每一个IO操作,系统都会为其分配一个不同的正整数,该正整数即为此IO操作的文件描述符
	e.g.:
	sys.stdin.fileno()
	>>>0
	sys.stdout.fileno()
	>>>1
	sys.stderr.fileno()
	>>>2

s.getsockname()
功能:获取套接字的绑定地址

s.getpeername()
功能:获取连接套接字另一段的地址(即客户端地址)(仅用于tcp的新套接字connfd)

s.setsockopt(level,optname,value)
e.g.:s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #重用端口
	 s.setsockopt(SOL_SOCKET,SO_BROADCAST,1) #收发广播
功能:设置套接字选项,丰富、修改原有套接字功能
参数:level:获取选项的类型
	optname:每个选项类型中的子选项
	value:为选项设置值

s.getsockopt(level,optname)
功能:获取套接字选项的值

udp套接字应用之广播(一端发送,多段接收)

目标地址:广播地址,每个网段最大的地址
172.60.50.255	==	<broadcast>

tcp应用之HTTP传输

http协议(超文本传输协议)	典型的应用层协议

用途:网页的获取,基于网站的数据传输
	基于http协议的数据传输
特点:
	1.应用层协议,传输层使用tcp传输
	2.灵活简单,和多种语言对接方便
	3.无状态协议,不记录用户的传输状态和通信内容
	4.成熟稳定(现版本http1.1 支持持久连接)
工作模式:
	1.使用http双方均遵循http协议规定发送和接收消息体
	2.请求方,根据协议内容组织请求内容发送给对方
	3.服务方,收到内容按照协议解析
	4.服务方,将回复内容按照协议组织发送给请求方
	5.请求方,收到回复根据协议解析

http请求(Request)
请求格式:
	请求行
		GET    	    	/   		HTTP/1.1
	  请求种类		请求内容			协议版本

		请求种类:GET 		获取网络资源
				POST		提交一定的附加数据,得到返回结果
				HEAD		获取响应头
				PUT			更新服务器资源
				DELETE		删除服务器资源
				CONNECT 	预留
				TRACE		测试
				OPTIONS		获取服务器性能

	请求头:对请求内容的具体描述
		*以键值对的形式对请求信息进行描述(一个键值对一行)
			e.g.:Accept: text/html

	空行

	请求体:提交具体的请求参数(可以没有)

http响应(Response)
响应格式:	
	响应行:反馈具体的响应情况(是否能满足请求)
		HTTP/1.1		200			OK
		版本信息		   响应码	  附加信息

			响应码:每个响应码对应一个附加信息
					1xx		提示信息,表示请求已被接受
					2xx		响应成功
					3xx		响应需要重新定向
					4xx		客户端错误
					5xx		服务器错误
			常见的响应码:200		成功
						404		请求页面不存在
						401		没有访问权限
						500		服务器发生未知错误
						503		服务器暂时无法执行

	响应头:对响应信息的具体描述
		*以键值对的形式对请求信息进行描述(一个键值对一行)

	空行

	响应体:将客户想要的内容进行返回

基础的http服务流程程序
1.接收http请求
2.给出一定的响应

IO
凡是在内存中存在数据交换的操作都可以认为是IO操作

e.g.:
	内存与磁盘交互		读写 read write
	内存与终端交互		print input
	内存与网络交互		recv send

IO密集型程序:程序的执行过程进行大量的IO操作,而只有较少的cpu运算.消耗计算机资源较少,运行时间长.

CPU密集型程序(计算密集型):程序运行中需要大量的cpu运算,IO操作较少.消耗cpu资源多,运行速度快

IO分类:
	1.阻塞IO:默认形态 	效率很低的一种IO
		阻塞情况:
			1.因为某种条件没有达到造成的阻塞
				e.g. input,accept,recv
			2.处理IO事件的时间消耗较长带来阻塞
				e.g. 文件的读写过程,网络数据发送过程
	2.非阻塞IO:通过修改IO事件的属性,使其变为非阻塞状态,即避免条件阻塞的情况
		1.往往与循环搭配使用,这样可以不断执行部分需要执行的代码,也不影响对阻塞条件是判断
			设置套接字为非阻塞
			s.setblocking()
			功能:设置套接字的阻塞状态
			参数:设置为False则套接字调用函数为非阻塞
		2.超时检测
			将原本阻塞的IO设置一个最长阻塞等待时间,在规定时间内如果达到条件则正常执行,否则结束阻塞
			s.settimeout(sec)
			功能:设置套接字超时时间
			参数:设置的时间
	3.IO多路复用:同时监控多个IO事件,当哪个IO事件准备就绪就执行哪个IO事件.此时形成多个IO事件都可以操作的现象,不必逐个等待执行.
		1.准备就绪:IO事件即将发生的临界状态
		2.import select
			select:支持Windows,Linux,Unix
			poll:支持Linux,Unix
			epoll:支持Linux,Unix
		3.(rlist, wlist, xlist) = select(rlist, wlist, xlist[, timeout])
		功能:监控IO事件,阻塞等待IO事件发生
		参数:
		rlist	列表		要监控的读IO事件(存放被动等待处理的IO事件 e.g.监听套接字)
		wlist	列表		要监控的写IO事件(存放需要主动处理的IO)
		xlist	列表		要监控的出错IO事件(存入如果发生异常需要处理的IO)
		timeout	超时时间
		返回值:
		rlist	列表		rlist中准备就绪的IO
		wlist	列表		wlist中准备就绪的IO
		xlist	列表		xlist中准备就绪的IO

		注意事项:
			1.IO多路复用处理IO的过程中不应有死循环出现,使得一个客户端长期占有服务端
			2.IO多路复用是一种并发行为,但是是单进程程序,效率较高

	4.事件IO
	5.异步IO
	......(前三个最常用)

位运算:按照二进制位来进行运算操作
	
	&	按位与
	|	按位或
	^	按位异或
	<<	左移
	>>	右移
移多少位乘/地板除多少个2

11			  1011
14			  1110
11 & 14 = 10 (1010)
11 | 14 = 15 (1111)
11 ^ 14 = 5  (0101)
11 << 2 = 44 (101100)
14 >> 2 = 3  (0011)

使用:
	1.在底层做硬件寄存器的操作
	2.做标志位的过滤选择

poll

	from select import poll

	1.创建poll对象
	p = poll()
	2.添加关注的IO
		POLLIN		rlist
		POLLOUT		wlist
		POLLERR		xlist
		POLLHUP		断开连接
		POLLPRI		紧急处理
		POLLVAL		无效

		p.register(s,POLLIN | POLLERR)
			关注一个IO就调用一个register,多个同时关注可以用'|(按位或)'间隔开

		p.unregister(s)
			取消对IO的关注

	3.进行监控
	events = p.poll()
	功能:监控关注的IO,阻塞等待IO发生
	返回值:events是一个列表,列表中每个元素为一个元组,代表的是准备就绪需要处理的IO

	events-->[(fileno,			event),(),()...]
			 就绪IO的fileno	  哪个IO事件就绪

	通过fileno获取IO对象调用函数

	实施方法:建立比照字典{s.fileno():s}

	4.处理IO

epoll
	使用方法:与poll基本相同
	1.生成对象使用epoll()
	2.register注册IO事件时,事件类型改为epoll事件类型

select	  poll    epoll  的区别
1.select可以很好支持Windows
2.epoll比select和poll效率高,select和poll差不多
	效率:epoll>(select=poll)
3.epoll提供了更多的触发方式

本地套接字

Linux下文件类型
b  块设备文件
c  字符设备文件
d  目录
-  普通文件
l  链接
s  套接字
p  管道

作用:用于本地不同程序之间进行通信

本地套接字创建流程
1.创建套接字对象
sockfd = socket(AF_UNIX,SOCK_STRAEM)

2.绑定本地套接字文件
sockfd.bind(path)
path:一个文件

3.监听
4.接收发送消息

os.path.exists(path)
功能:判断一个文件夹下是否有某个文件
返回值:True/False

os.unlink(path)  os.remove(path)
功能:删除一个文件

多任务编程
意义:充分利用计算机的资源提高程序的运行效率
定义:通过应用程序利用计算机多个核心,达到同时执行多个任务的目的
实施方案:多进程  多线程

并行:多个计算机核心在同时处理多个任务,多个任务之间的关系就是并行

并发:计算机同时处理多个任务,内核在多个任务间不断切换,达到好像在同时处理的运行效果.此时多个任务实际为并发关系

进程:程序在计算机中运行一次的过程,是一个动态的过程描述,占有cpu内存等计算机资源的,有一定生命周期

程序:是一个可执行文件,是静态的,占有磁盘,不占有计算机运行资源

同一个程序的不同执行过程是不同的进程,因为分配的计算机资源等均不同

进程的创建流程
	1.用户空间运行一个程序,发起进程创建
	2.操作系统接收用户请求,开启进程创建
	3.操作系统分配系统资源,确定进程状态
	4.将创建好的进程提供给应用层使用

cpu时间片
	如果一个进程占有计算机核心,则该进程在cpu时间片上.
	多个任务实际上会对cpu进行争夺,一般由操作系统分配cpu时间片

PCB(进程控制块)
	在操作系统中,进程创建后会自动产生一个空间存放进程信息,称为进程控制块

进程信息:进程PID,进程占有的内存位置,创建时间,用户...

进程PID:进程在操作系统中的唯一编号,大于0的整数,由系统自动分配

进程信息查看命令:ps -aux

进程特征
	1.进程是操作系统分配计算机资源的最小单位
	2.每个进程都有自己单独的虚拟内存空间
	3.进程间的执行各自独立,互不影响

进程状态
	三态:
		1.就绪态:进程具备执行条件,等待系统分配处理
		2.运行(/执行)态:进程占有cpu处理器,处于运行状态
		3.等待态:进程暂时不具备运行条件,需要阻塞等待

	五态(三态基础上增加新建态和终止态):
		1.新建态:创建一个新的进程,获取资源的过程
		2.终止态:进程结束释放资源的过程

	种类:
	  首字母
		D  等待态  不可中断等待
		S  等待态  可中断等待
		T  等待态  暂停状态
		R  运行态  就绪态+运行态
		Z  僵尸态  

		+  前台进程  在终端上直接显示的进程
		<  高优先级
		N  低优先级
		l  有进程连接
		s  会话组组长  

进程优先级
	优先级决定了一个进程的执行权限和占有资源的优先程度

查看进程优先级
	top:动态地查看进程优先级
	取值范围:-20~19(-20优先级最高,默认给0)
	nice:指定优先级运行程序
		e.g. nice -9 ./while.py
			sudo nice --9 ./while.py(-9优先级,小于0的加sudo)

父子进程
	在系统中,除了初始化进程,每个进程都有一个父进程,可以有0个或多个子进程
	由此形成父子进程关系.可以认为每个进程都是父进程发起请求创建的

进程(process)
查看进程树:pstree
查看父进程PID(PPID):ps -ajx

import os
pid = os.fork()
功能:创建一个子进程
参数:无
返回值:失败返回一个负数(-1)
		成功1.在原有的进程中返回子进程的PID
			2.在子进程中返回0

1.子进程会复制父进程全部代码段,包括fork前的代码(复制了整个内存空间)
2.子进程从fork的下一句开始执行(赋值开始)
3.父子进程通常会根据fork返回值的差异选择执行不同的代码(使用if结构)
4.父子进程在执行上互不干扰,执行顺序不确定
5.子进程虽然复制父进程的内存空间,但是有自己的特性,比如PID号,PCB等
6.父子进程空间独立,各自修改各自的内容,互不影响

进程相关函数使用
os.getpid()
功能:获取当前进程的PID号
返回值:返回PID号

os.getppid()
功能:获取父进程的PID号
返回值:返回PID号

os._exit(status)
功能:退出进程
参数:整数  表示进程的退出状态	
	正常退出		0
	异常退出		负数

sys.exit([status])
功能:退出程序
参数:默认为0  如果是整数则表示退出状态
			 如果是字符串则表示退出时打印的内容
*可以通过捕获SystemExit异常阻止退出
import sys
try:
	sys.exit('进程退出')
except SystemExit as e:
	print(e)

print('Process end')
>>>进程退出
Process end

孤儿进程:父进程先于子进程退出,此时子进程就会成为孤儿进程
*孤儿进程会被系统指定的进程收养,此时该进程会变成该孤儿进程新的父进程
*孤儿进程退出时,新的父进程会处理其退出状态

僵尸进程:子进程先于父进程退出,父进程没有处理子进程退出状态,此时子进程成为僵尸进程
	特点:僵尸进程已经结束,但是会滞留部分PCB信息在内存,大量的僵尸会消耗系统资源,应该尽量避免

避免僵尸进程产生:
	1.父进程先退出
		创建二级子进程
			1.父进程创建子进程等待子进程退出
			2.子进程创建二级子进程,然后马上退出
			3.二级子进程成为孤儿,处理具体事件
	2.父进程处理子进程退出状态
		pid,status = os.wait()
		功能:在父进程中阻塞等待处理子进程的退出
		返回值:pid    退出的子进程的PID号
			  status  子进程的退出状态

		pid,status = os.waitpid(pid, option)
		功能:同wait
		参数:
			pid    -1  表示任意子进程退出
				   >0  整数  指定PID号的子进程退出
			option  0   		表示阻塞等待
					WNOHANG  	表示非阻塞
		返回值:同wait

		os.WEXITSTATUS(status)
		功能:获取子进程退出状态

		*waitpid(-1, 0) == wait()

multiprocessing 模块创建进程(Python的标准库模块)
1.需要将要做的事件封装成函数
2.在multiprocessing中提供的Process类创建进程对象
3.通过进程对象和Process 初始化函数对进程进行设置,并绑定要执行的事件
4.启动进程会自动执行相关联函数
5.事件完成后回收进程

创建进程对象
Process()
功能:创建进程对象
参数:
	name:给创建的进程对象起一个名字
		默认为Process-x
	target:绑定的函数
	args:元组 给target函数按照位置传参
	kwargs:字典 给target函数按照键值传参

p.start()
功能:启动进程,此时进程被创建.自动运行进程函数

p.join([timeout])
功能:阻塞等待回收响应的进程
参数:设置超时时间(不给定就一直等待)
	
*multiprocessing创建的进程是原来进程的子进程,创建后父子进程各自执行互不影响
*子进程同样是复制父进程的空间,子进程对内容的修改不会影响父进程空间
*join回收子进程,会有效地阻止僵尸进程的产生

通常使用multiprocessing创建进程,父进程只用作进程的创建和回收,不做其他工作

multiprocessing 进程对象属性

p.is_alive()  
功能:判断子进程生命周期状态
返回值:True/False

p.name  进程名称  默认为Process1  如果起名字则为自定义名称

p.pid  创建的进程的PID

p.daemon
	默认值为False	父进程退出不会影响子进程的运行
	如果设置为True	则父进程退出子进程也会退出
	注意:
		1.daemon的设置必须在start之前
		2.如果设置daemon为True则不再使用join

创建自己的进程类
	1.继承Process类(重写__init__并且调用父类的__init__)
	2.重写run方法,此时生成对象后,调用start就会自动运行run

多进程
	优点:
		1.并行执行多个任务,提高效率
		2.创建方便,运行独立,不受其他进程影响
		3.数据安全
	缺点:
		1.进程的创建和删除都需要消耗计算机资源

进程池技术:
	产生原因:如果有大量的任务需要多进程完成,且可能需要频繁地创建和删除进程,给计算机带来大量的资源消耗,则需要使用进程池技术

	原理:在进程池内运行一定数量的进程,通过这些进程完成进程池队列中的事件,直到所有事件执行完毕,以减少进程不断创建和删除的过程

	实施操作方法:
	1.创建进程池,在进程池中放入适当进程
	2.将事件加入到进程池队列
	3.事件不断运行,直到所有事件运行完毕
	4.关闭进程池,回收进程

	from multiprocessing import Pool

	pool = Pool(processes)
	功能:创建进程池对象
	参数:表示进程池中有多少进程

	pool.apply_async(func,args,kwds)
	功能:将事件放入进程池队列
	参数:func	要执行的事件
		args	给func用元组传参
		kwds	给func用字典传参
	返回值:返回事件对象	通过get()方法获取事件函数返回值

	pool.apply(func,args,kwds)
	功能:将事件放入进程池队列
	参数:func	要执行的事件
		args	给func用元组传参
		kwds	给func用字典传参
	返回值:无
	注意:用得比较少,因为顺序投放事件

	pool.close()
	功能:关闭进程池,不能再添加新的事件

	pool.join()
	功能:阻塞等待回收进程池

	pool.map(func, iter)
	功能:将要完成的事件放入进程池
	参数:func	要完成的事件函数
		iter 	可迭代对象给func传参
	返回值:事件函数的返回值列表

获取文件大小
os.path.getsize(path)
功能:获取一个文件的大小
参数:一个文件

进程间通信
进程间由于空间独立,资源无法互相直接获取,此时在不同的进程间进行数据传递就需要专门的通信方法

进程间通讯方法(IPC)
管道  消息队列  共享内存  信号  信息量  套接字

管道通信 Pipe
管道:在内存中开辟一段空间,形成管道结构.管道对多个进程可见,进程可以对管道进行读写操作

multiprocessing-->Pipe

fd1,fd2 = Pipe(duplex = True)
功能:创建一个管道
参数:默认为双向管道
	 如果设置为False则为单向管道
返回值:如果双向管道,fd1,fd2都可以进行读写操作
		单向管道,则fd1只可读,fd2只可写

fd.recv()
功能:从管道读取内容
返回值:读到的内容
*如果管道无内容则阻塞

fd.send(data)
功能:向管道写入内容
参数:要发送的内容
*几乎可以发送所有Python支持的数据

消息队列
队列:先进先出  在内存中开辟出队列结构空间,多个进程可以向队列投放消息,在取出的时候按照存入顺序取出

创建队列
q = Queue(maxsize = 0)
功能:创建队列
参数:maxsize  默认表示根据系统分配空间存储消息
	如果传入一个正整数则表示最多可以存放多少条消息
返回值:队列对象

q.put(data,[block,timeout])
功能:存放消息
参数:data  存入的消息(支持Python数据类型)
	block  默认为True 表示队列满时阻塞
			设置为False则表示非阻塞
	timeout  当block为True时表示超时时间

data = q.get([block,timeout])
功能:取出消息
参数:block  默认为True 表示队列空时阻塞
			设置为False则表示非阻塞
	timeout  当block为True时表示超时时间
返回值:获取到的消息

q.full()  判断队列是否为满
q.empty()  判断队列是否为空
q.qsize()  判断当前队列有多少消息(Mac没有该函数)
q.close()  关闭队列

共享内存
在内存中开辟一段空间,存储数据,对多个进程可见.
每次写入共享内存中的数据会覆盖之前的内容

from multiprocessing import Value

obj = Value(ctype, obj)
功能:开辟共享内存空间
参数:ctype  字符串  要转变的c的数据类型(对比类型对照表)
	 obj  共享内存的初始化数据
返回值:共享内存对象

obj.value  表示共享内存中的值.可迭代,对其修改或使用即可

obj = Array(ctype, obj)
功能:开辟共享内存
参数:ctype  要转换的c的类型
	 obj  要存入共享内存的数据
	 		列表  将列表存入共享内存,要求数据类型一致
	 		正整数  表示开辟几个数据空间

	 		管道    			  消息队列	      共享内存
开辟空间  	内存  			  内存  		      内存

读写方式    两端读写			  先进先出	      操作覆盖内存
			双向/单向

效率 		一般 			  一般 		      较快

应用 		多用于两端通信	  使用广泛	      复杂,需要同步互斥机制


信号
一个进程向另一个进程通过信号传递某种讯息,接收方在接收到信号后进行相应的处理
*终端输入kill -l查看信号

kill  -signum  PID  给PID的进程发送一个信号

关于信号
信号名称:信号的名字或者数字
信号含义:信号的作用
默认行为:当一个进程接收到信号时采取的行为
		主要终止进程,暂停进程,忽略产生
e.g.
SIGHUP		终端断开
SIGINT		ctrl + c
SIGQUIT		ctrl + \
SIGTSTP		ctrl + z
SIGKILL		终止进程且不能被处理
SIGSTOP		暂停进程且不能被处理
SIGALRM		时钟信号
SIGCHLD		子进程状态改变发送给父进程

通过Python进行信号处理
os.kill(pid,sig)
功能:发送信号给某个进程
参数:pid  给哪个进程发送信号
	sig   给什么信号

signal.alarm(sec)
功能:一定时间后给自身发送一个SIGALRM信号
参数:指定时间
*一个进程中只能设置一个时钟,第二个时钟会覆盖之前的时钟

程序执行的同步和异步
同步:按照步骤一步一步顺序执行
异步:在程序执行中利用内核,不影响应用层程序持续执行
*信号是唯一的异步通信方式

signal.pause()
功能:阻塞等待一个信号的发生

signal.signal(signum,handler)
功能:处理信号
参数:signum:要处理的信号
	handler:信号的处理方法
		SIG_DFL  表示使用默认的方法处理
		SIG_IGN  表示忽略这个信号
		func 	 自定义函数处理信号
			def func(sig, frame):
				pass
			sig 表示要处理的信号
			frame 信号的结构对象

*signal函数是一个异步处理函数
*signal函数不能处理SIGKILL SIGSTOP信号
*在父进程中使用signal(SIGCHLD,SIG_IGN),此时子进程退出会有系统自动处理


信号量
给定一定的数量,对多个进程可见,并且多个进程根据信号量的多少确定不同的行为

from multiprocessing import Semaphore

sem = Semaphore(num)
功能:生成信号量对象
参数:信号量的初始值
返回值:信号量对象

sem.acquire()  信号量对象减1  信号量为0时会阻塞
sem.release()  信号量对象加1
sem.get_value()  获取当前信号量数量


同步互斥机制
	目的:解决对共有资源操作产生的争夺

临界资源:多个进程或者线程都能够操作的资源
临界区:操作临界资源的代码段

同步:是一种合作关系,为完成某个任务,多进程或者多线程之间形成一种协调.按照约定依次执行对临界资源的操作,相互告知相互促进.
互斥:是一种制约关系,当一个进程占有临界资源就会加锁的操作,此时其他进程就无法操作该临界资源.直到使用的进程进行解锁操作后才能使用.

Event 事件
from multiprocessing import Event

	创建事件对象
	e = Event()

	事件阻塞
	e.wait([timeout])

	事件设置
	e.set()
	功能:当e被set()后,e.wait()不再阻塞

	事件清除
	e.clear()
	功能:当e被clear(),e.wait()又会阻塞

	事件判断  判断当前事件对象是否被设置
	e.is_set()

Lock 锁
from multiprocessing import Lock

	创建对象
	lock = Lock()

	lock.acquire()  上锁
	lock.release()  解锁

	上锁状态:执行acquire()操作会阻塞
	解锁状态:执行acquire()不阻塞

	with lock:  #等同于上锁
		...
		...
				#with代码段结束即解锁

线程:一种多任务编程的方式,可以使用计算机多核资源.线程又被称为轻量级的进程
	特征:
		1.线程是计算机核心分配的最小单位
		2.一个进程可以包含多个线程
		3.线程也是一个运行过程,也要消耗计算机资源.多个线程共享其进程的资源和空间
		4.线程也拥有自己特有的资源属性,比如指令集,TID等
		5.线程的创建\删除\运行,对资源的消耗都小于进程
		6.多个线程之间并行执行,互不干扰

threading 模块创建线程

t = threading.Thread()
功能:创建线程对象
参数:name  		  线程名称
	target  	  线程函数
	args  	元组  给线程函数传参
	kwargs  字典  给线程函数传参

t.start()  启动线程
t.join([timeout])  回收线程

线程属性
t.is_alive()  查看线程状态
t.name  线程名称
t.setName()  设置线程名称
threading.currentThread()  获取当前线程

t.daemon
默认情况下,主线的结束不会影响分支线程
如果设置为True,则主线程退出分支线程也会退出

设置方法:
t.daemon = True
t.setDaemon(True)

判断daemon属性:
t.isDaemon()

*线程daemon属性的设置在start前
*一般设置daemon后不会再使用join

创建自己的线程类
1.继承Thread类
2.运行Thread类中的__init__方法以获取父类属性
3.重写run方法

第三方模块:threadpool

线程通信
通信方法:多个线程共用进程空间,所以进程的全局变量对进程内的线程均可见.因此使用全局变量通信是线程主要通信方法
注意事项:线程间通信更容易产生资源争夺,往往需要同步互斥机制保证通信安全

线程的同步互斥

线程的Event事件

操作:
	e = threading.Event()
	e.wait([timeout])  如果e为设置状态则不阻塞,未设置则阻塞
	e.set()  将e变为设置状态
	e.clear()  将e设置去除

线程锁
	lock = threading.Lock()  创建锁
	lock.acquire()  上锁
	lock.release()  解锁
	操作原理:重复上锁acquire()会阻塞

python线程的GIL问题(全局解释器锁)

python-->支持多线-->同步互斥-->加锁-->超级锁(给解释器加锁)

后果:一个解释器,同一时刻只能解释一个线程.大大降低了python多线程的执行效率.

python的GIL问题的解决方案
	1.尽量使用进程
	2.不使用c\c++作为解释器	可以用c#\java解释器
	3.python线程适用于高延迟的IO操作,网络操作,不适用于cpu密集型或者传输速度很快的IO操作

*线程遇到阻塞时会让出解释器

效率测试:进程效率较高,而线程由于受GIL问题影响效率较低

进程和线程的区别和联系
1.两者都是多任务编程的方式,都能够使用计算机多核资源
2.进程的创建和删除要比线程消耗更多的计算机资源
3.进程空间独立,数据安全性好,有专门的通信方法
4.线程使用全局变量通信,更加简单,但是往往需要同步互斥操作
5.一个进程可以包含多个线程,线程共享进程的资源
6.进程线程都有自己的特有属性资源,如:命令,属性,id 等

使用场景:
1.如果需要创建较多的并发,任务比较简单,线程比较合适
2.如果数据操作和功能比较独立,此时使用进程会比较合适
3.使用线程时要考虑到同步互斥的复杂程度
4.python线程需要考虑到GIL问题

总结:
1.进程线程的特征
2.进程线程区别和关系
3.同步互斥的意义,用过什么方法,什么情况下用的
4.进程间通信方式都知道哪些,有什么特点
5.僵尸进程怎么处理,线程的GIL问题怎么看
6.给一个情景,问选择进程还是线程,为什么